<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modules &mdash; PyTrx 1.2.4 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Links and Acknowledgements" href="Links.html" />
    <link rel="prev" title="Package Guide" href="Guide.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> PyTrx
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="GetStarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Guide.html">Package Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-Area">Area module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-CamEnv">CamEnv module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-DEM">DEM module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-FileHandler">FileHandler module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Images">Images module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Line">Line module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Utilities">Utilities module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Velocity">Velocity module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Links.html">Links and Acknowledgements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyTrx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Modules</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Packages.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modules">
<h1>Modules<a class="headerlink" href="#modules" title="Permalink to this headline"></a></h1>
<section id="module-Area">
<span id="area-module"></span><h2>Area module<a class="headerlink" href="#module-Area" title="Permalink to this headline"></a></h2>
<p>The Area module handles the functionality for obtaining areal measurements from
oblique time-lapse imagery. Specifically, this module contains functions for:
(1) Performing automated and manual detection of areal extents in oblique
imagery; and (2) Determining real-world surface areas from oblique imagery.</p>
<dl class="py class">
<dt class="sig sig-object py" id="Area.Area">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Area.</span></span><span class="sig-name descname"><span class="pre">Area</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imageList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cameraenv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibFlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#Images.ImageSequence" title="Images.ImageSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Images.ImageSequence</span></code></a></p>
<p>A class for processing change in area (i.e. a lake or plume) through an
image sequence, with methods to calculate extent change in an image plane
(px) and real areal change via georectification</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~Area._camEnv</strong> (<em>PyTrx.CamEnv.CamEnv</em>) – Camera environment object</p></li>
<li><p><strong>~Area._calibFlag</strong> (<em>bool</em>) – Camera calibration flag</p></li>
<li><p><strong>~Area._pxplot</strong> (<em>list</em>) – Pixel plotting extent</p></li>
<li><p><strong>~Area._maximg</strong> (<em>int</em>) – Image with maximum extent</p></li>
<li><p><strong>~Area._mask</strong> (<em>arr</em>) – Image mask</p></li>
<li><p><strong>~Area._enhance</strong> (<em>list</em>) – Image enhancement parameters</p></li>
<li><p><strong>~Area._hmatrix</strong> (<em>arr</em>) – Homography matrix</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.calcAutoAreas">
<span class="sig-name descname"><span class="pre">calcAutoAreas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">colour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.calcAutoAreas" title="Permalink to this definition"></a></dt>
<dd><p>Detects areas of interest from a sequence of images, and returns
pixel and xyz areas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>colour</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether colour range for detection should be defined
for each image or only once (default=False)</p></li>
<li><p><strong>verify</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether detected polygons should be manually verified
by user (default=False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>XYZ and UV area information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.calcManualAreas">
<span class="sig-name descname"><span class="pre">calcManualAreas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.calcManualAreas" title="Permalink to this definition"></a></dt>
<dd><p>Manually define areas of interest in a sequence of images. User
input is facilitated through an interactive plot to click around the
area of interest</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>XYZ and UV area information</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.setColourrange">
<span class="sig-name descname"><span class="pre">setColourrange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.setColourrange" title="Permalink to this definition"></a></dt>
<dd><p>Manually define the RBG colour range that will be used to filter
the image/images.</p>
<dl class="simple">
<dt>upper<span class="classifier">int</span></dt><dd><p>Upper value of colour range</p>
</dd>
<dt>lower<span class="classifier">int</span></dt><dd><p>Lower value of colour range</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.setEnhance">
<span class="sig-name descname"><span class="pre">setEnhance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.setEnhance" title="Permalink to this definition"></a></dt>
<dd><p>Set image enhancement parameters. Change brightness and contrast of
image using phi and theta variables. Change phi and theta values
accordingly. See enhanceImg function for detailed explanation of the
parameters.</p>
<dl class="simple">
<dt>diff<span class="classifier">str</span></dt><dd><p>Inputted as either ‘light or ‘dark’, signifying the intensity of the
image pixels. ‘light’ increases the intensity such that dark pixels
become much brighter and bright pixels become slightly brighter.
‘dark’ decreases the intensity such that dark pixels become much
darker and bright pixels become slightly darker</p>
</dd>
<dt>phi<span class="classifier">int</span></dt><dd><p>Defines the intensity of all pixel values</p>
</dd>
<dt>theta<span class="classifier">int</span></dt><dd><p>Defines the number of “colours” in the image, e.g. 3 signifies that
all the pixels will be grouped into one of three pixel values              .</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.setMax">
<span class="sig-name descname"><span class="pre">setMax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maxMaskPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.setMax" title="Permalink to this definition"></a></dt>
<dd><p>Set image in sequence which pictures the maximum extent of the area
of interest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxMaskPath</strong> (<em>str</em>) – File path to mask with maximum extent</p></li>
<li><p><strong>maxim</strong> (<em>arr</em>) – Image with maximum extent</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.setPXExt">
<span class="sig-name descname"><span class="pre">setPXExt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.setPXExt" title="Permalink to this definition"></a></dt>
<dd><p>Set plotting extent. Setting the plot extent will make it easier to
define colour ranges and verify areas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xmin</strong> (<em>int</em>) – X-axis minimum value</p></li>
<li><p><strong>xmax</strong> (<em>int</em>) – X-axis maximum value</p></li>
<li><p><strong>ymin</strong> (<em>int</em>) – Y-axis minimum value</p></li>
<li><p><strong>ymax</strong> (<em>int</em>) – Y-axis maximum value</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.setThreshold">
<span class="sig-name descname"><span class="pre">setThreshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.setThreshold" title="Permalink to this definition"></a></dt>
<dd><p>Set threshold for number of polgons kept from an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>number</strong> (<em>int</em>) – Number denoting the number of detected polygons that will be retained</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.Area.verifyAreas">
<span class="sig-name descname"><span class="pre">verifyAreas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">areas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.Area.verifyAreas" title="Permalink to this definition"></a></dt>
<dd><p>Method to manually verify all polygons in images. Plots sequential
images with detected polygons and the user manually verifies them by
clicking them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>area</strong> (<em>list</em>) – XYZ and UV area information</p></li>
<li><p><strong>invprojvars</strong> (<em>list</em>) – Inverse projection variables [X,Y,Z,uv0]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>verified</strong> – Verified XYZ and UV area information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Area.TestArea">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Area.</span></span><span class="sig-name descname"><span class="pre">TestArea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.TestArea" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="Area.TestArea.test_calcAutoArea">
<span class="sig-name descname"><span class="pre">test_calcAutoArea</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Area.TestArea.test_calcAutoArea" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Area.TestArea.test_getOGRArea">
<span class="sig-name descname"><span class="pre">test_getOGRArea</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Area.TestArea.test_getOGRArea" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Area.calcAutoArea">
<span class="sig-prename descclassname"><span class="pre">Area.</span></span><span class="sig-name descname"><span class="pre">calcAutoArea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourrange</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmatrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.calcAutoArea" title="Permalink to this definition"></a></dt>
<dd><p>Detects areas of interest from a given image, and returns pixel and xyz
areas along with polygon coordinates. Detection is performed from the image
using a predefined RBG colour range. The colour range is then used to
extract pixels within that range using the OpenCV function inRange. If a
threshold has been set (using the setThreshold function) then only nth
polygons will be retained. XYZ areas and polygon coordinates are only
calculated when a set of inverse projection variables are provided</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>imn</strong> (<em>str</em>) – Image name</p></li>
<li><p><strong>colourrange</strong> (<em>list</em>) – RBG colour range for areas to be detected from</p></li>
<li><p><strong>hmatrix</strong> (<em>arr</em>) – Homography matrix (default=None)</p></li>
<li><p><strong>threshold</strong> (<em>int</em><em>, </em><em>optional</em>) – Threshold number of detected areas to retain (default=None)</p></li>
<li><p><strong>invprojvars</strong> (<em>list</em><em>, </em><em>optional</em>) – Inverse projection variables [X,Y,Z,uv0] (default=None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Four list items containing 1) the sum of total detected areas (xyz), 2)
XYZ coordinates of detected areas, 3) Sum of total detected areas (px),
and 4) UV coordinates of detected areas</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Area.calcManualArea">
<span class="sig-prename descclassname"><span class="pre">Area.</span></span><span class="sig-name descname"><span class="pre">calcManualArea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmatrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pxplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.calcManualArea" title="Permalink to this definition"></a></dt>
<dd><p>Manually define an area in a given image. User input is facilitated
through an interactive plot to click around the area of interest. XYZ areas
are calculated if a set of inverse projection variables are given</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>imn</strong> (<em>str</em>) – Image name</p></li>
<li><p><strong>hmatrix</strong> (<em>arr</em><em>, </em><em>optional</em>) – Homography matrix (default=None)</p></li>
<li><p><strong>pxplot</strong> (<em>list</em><em>, </em><em>optional</em>) – Plotting extent for manual area definition (default=None)</p></li>
<li><p><strong>invprojvars</strong> (<em>list</em><em>, </em><em>optional</em>) – Inverse projection variables [X,Y,Z,uv0] (default=None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Four list items containing 1) the sum of total detected areas (xyz), 2)
XYZ coordinates of detected areas, 3) Sum of total detected areas (px),
and 4) UV coordinates of detected areas</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Area.defineColourrange">
<span class="sig-prename descclassname"><span class="pre">Area.</span></span><span class="sig-name descname"><span class="pre">defineColourrange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pxplot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.defineColourrange" title="Permalink to this definition"></a></dt>
<dd><p>Define colour range manually by clicking on the lightest and
darkest regions of the target extent that will be defined. Plot interaction
information: Left click to select, right click to undo selection, close the
image window to continue, and the window automatically times out after two
clicks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>imn</strong> (<em>str</em>) – Image name</p></li>
<li><p><strong>pxplot</strong> (<em>list</em><em>, </em><em>optional</em>) – Plotting extent for manual area definition, default to None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List containing the upper and lower boundary for pixel detection</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Area.getOGRArea">
<span class="sig-prename descclassname"><span class="pre">Area.</span></span><span class="sig-name descname"><span class="pre">getOGRArea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Area.getOGRArea" title="Permalink to this definition"></a></dt>
<dd><p>Get real world OGR polygons (.shp) from xyz poly pts with real world
points which are compatible with mapping software (e.g. QGIS)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pts</strong> (<em>arr</em>) – UV/XYZ coordinates of a given area shape</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of OGR geometry polygons</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-CamEnv">
<span id="camenv-module"></span><h2>CamEnv module<a class="headerlink" href="#module-CamEnv" title="Permalink to this headline"></a></h2>
<p>The Camera Environment module contains the object-constructors and functions
for: (1) Representing a camera model in three-dimensional space; and (2)
Effective translation of measurements in an XY image plane to XYZ real-world
coordinates. The projection and inverse transformation functions are based on
those available in the ImGRAFT toolbox for Matlab. Translations from
ImGRAFT are noted in related script comments.</p>
<dl class="py class">
<dt class="sig sig-object py" id="CamEnv.CamCalib">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">CamCalib</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamCalib" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This base class models a standard camera calibration matrix as per
OpenCV, MatLab and ImGRAFT. The class uses a standard pinhole camera model,
drawing on the functions within OpenCV. A scene view is formed by
projecting 3D points into the image plane using a perspective
transformation.
The camera intrinsic matrix is defined as a 3 x 3 array: [fx,0,0][s,fy,0]
[cx,cy,1], where fx and fy is the camera focal length (in pixel units) and
cx and cy as the location of the image centre (in pixels too), s is the
skew, and cx and cy are the image dimensions in pixels.
In addition, the radial distortion and tangential distortion are
represented as a series of coefficients. These distortions are introduced
by discrepancies in the camera lens and between the lens and the camera
sensor: 1) Radial Distortion Coefficients: k ([k1,k2,k3,k4,k5,k6]), between
2 and 6 coefficients needed; and 2) Tangential Distortion Coefficients:
p ([p1,p2])
The object can be initiated directly either as a list of three elements for
each of the intrinsic, tangential and radial arrays, or by referencing a
file (.mat or .txt) containing the calibration data in a pre-designated
format</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~CamCalib._intrMat</strong> (<em>arr</em>) – Intrinsic camera matrix</p></li>
<li><p><strong>~CamCalib._intrMat</strong> – OpenCV-compatiable intrinsic camera matrix</p></li>
<li><p><strong>~CamCalib._tanCorr</strong> (<em>list</em>) – Tangential lens correction coefficients</p></li>
<li><p><strong>~CamCalib._radCorr</strong> (<em>list</em>) – Radial lens correction coefficients</p></li>
<li><p><strong>~CamCalib._calibErr</strong> (<em>int</em>) – Calibration residual error</p></li>
<li><p><strong>~CamCalib._focLen</strong> (<em>list</em>) – Camera focal length (px)</p></li>
<li><p><strong>~CamCalib._camCen</strong> (<em>list</em>) – Camera principal point</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamCalib.checkMatrix">
<span class="sig-name descname"><span class="pre">checkMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamCalib.checkMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Function to support the calibrate function. Checks and converts the
intrinsic matrix to the correct format for calibration with opencv.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>arr</em>) – Intrinsic camera matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The object’s intrinsic matrix (checked), tangential distortion and
radial distortion information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamCalib.getCalibdata">
<span class="sig-name descname"><span class="pre">getCalibdata</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamCalib.getCalibdata" title="Permalink to this definition"></a></dt>
<dd><p>Return camera matrix, and tangential and radial distortion
coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamCalib.getCamMatrix">
<span class="sig-name descname"><span class="pre">getCamMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamCalib.getCamMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Return camera matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamCalib.getCamMatrixCV2">
<span class="sig-name descname"><span class="pre">getCamMatrixCV2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamCalib.getCamMatrixCV2" title="Permalink to this definition"></a></dt>
<dd><p>Return camera matrix in a structure that is compatible with
subsequent photogrammetric processing using OpenCV</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamCalib.getDistortCoeffsCV2">
<span class="sig-name descname"><span class="pre">getDistortCoeffsCV2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamCalib.getDistortCoeffsCV2" title="Permalink to this definition"></a></dt>
<dd><p>Return radial and tangential distortion coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamCalib.reportCalibData">
<span class="sig-name descname"><span class="pre">reportCalibData</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamCalib.reportCalibData" title="Permalink to this definition"></a></dt>
<dd><p>Self reporter for Camera Calibration object data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="CamEnv.CamEnv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">CamEnv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envFile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#CamEnv.CamCalib" title="CamEnv.CamCalib"><code class="xref py py-class docutils literal notranslate"><span class="pre">CamEnv.CamCalib</span></code></a></p>
<p>A class to represent the camera object, containing the intrinsic
matrix, distortion parameters and camera pose (position and direction).
Also inherits from the <code class="xref py py-class docutils literal notranslate"><span class="pre">PyTrx.CamEnv.CamCalib</span></code> object, representing
the intrinsic camera information.
This object can be initialised either through an environment file (and
passed to the initialiser as a filepath), or with the set intput parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~CamEnv._name</strong> (<em>str</em>) – The reference name for the camera</p></li>
<li><p><strong>~CamEnv._GCPpath</strong> (<em>str</em>) – The file path of the GCPs, for the GCPs object</p></li>
<li><p><strong>~CamEnv._DEMpath</strong> (<em>str</em>) – The file path for the DEM, for the GCPs object</p></li>
<li><p><strong>~CamEnv._DEMdensify</strong> (<em>int</em>) – DEM densification factor</p></li>
<li><p><strong>~CamEnv._DEM</strong> (<em>PyTrx.DEM.ExplicitRaster object</em>) – DEM object</p></li>
<li><p><strong>~CamEnv._invProjVars</strong> (<em>list</em>) – Inverse projection variables</p></li>
<li><p><strong>~CamEnv._imagePath</strong> (<em>str</em>) – The file path for the GCP reference image, for the GCPs object</p></li>
<li><p><strong>~CamEnv._calibPath</strong> (<em>str</em>) – The file path for the calibration file. This can be either as a .mat
Matlab file or a text file. The text file should be of the following tab
delimited format: RadialDistortion [k1 k2 k3…k7],
TangentialDistortion [p1 p2], IntrinsicMatrix [x y z][x y z][x y z] End</p></li>
<li><p><strong>~CamEnv._camLoc</strong> (<em>list</em>) – The x,y,z coordinates of the camera location, as a list</p></li>
<li><p><strong>~CamEnv._camDirection</strong> (<em>list</em>) – The yaw, pitch and roll of the camera, as a list</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.dataFromFile">
<span class="sig-name descname"><span class="pre">dataFromFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.dataFromFile" title="Permalink to this definition"></a></dt>
<dd><p>Read CamEnv data from .txt file containing keywords and filepaths
to associated data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – Environment file path</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Camera environment information (name, GCP filepath, DEM filepath,
image filepath, calibration file path, camera coordinates, camera
pose (ypr) and DEM densification factor)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.getDEM">
<span class="sig-name descname"><span class="pre">getDEM</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.getDEM" title="Permalink to this definition"></a></dt>
<dd><p>Return DEM as PyTrx.DEM.ExplicitRaster object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.getRefImageSize">
<span class="sig-name descname"><span class="pre">getRefImageSize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.getRefImageSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the dimensions of the reference image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.optimiseCamEnv">
<span class="sig-name descname"><span class="pre">optimiseCamEnv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.optimiseCamEnv" title="Permalink to this definition"></a></dt>
<dd><p>Optimise projection variables in the camera environment. The precise
parameters to optimise are defined by the optimise variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optimise</strong> (<em>str</em>) – Parameters to optimise - ‘YPR’ (optimise camera pose only), ‘EXT’
(optimise external camera parameters), ‘INT’ (optimise internal
camera parameters), or ‘ALL’ (optimise all projection parameters)</p></li>
<li><p><strong>optmethod</strong> (<em>str</em><em>, </em><em>optional</em>) – Optimisation method (default=’trf’)</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote if optimisation output should be plotted
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.reportCamData">
<span class="sig-name descname"><span class="pre">reportCamData</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.reportCamData" title="Permalink to this definition"></a></dt>
<dd><p>Reporter for testing that the relevant data has been successfully
imported. Testing for camera Environment name, camera location (xyz),
reference image, DEM, DEM densification, GCPs, yaw pitch roll, camera
matrix, and distortion coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.showCalib">
<span class="sig-name descname"><span class="pre">showCalib</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.showCalib" title="Permalink to this definition"></a></dt>
<dd><p>Plot corrected and uncorrected reference image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.showGCPs">
<span class="sig-name descname"><span class="pre">showGCPs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.showGCPs" title="Permalink to this definition"></a></dt>
<dd><p>Plot GCPs in image plane and DEM scene</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.showPrincipalPoint">
<span class="sig-name descname"><span class="pre">showPrincipalPoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.showPrincipalPoint" title="Permalink to this definition"></a></dt>
<dd><p>Plot Principal Point on reference image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.CamEnv.showResiduals">
<span class="sig-name descname"><span class="pre">showResiduals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.CamEnv.showResiduals" title="Permalink to this definition"></a></dt>
<dd><p>Show positions of xyz GCPs and projected GCPs, and residual
differences between their positions. This can be used as a measure of
a error in the georectification of measurements</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="CamEnv.GCPs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">GCPs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">GCPpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imagePath</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.GCPs" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class representing the geography of the camera scene. Contains
ground control points, as the world and image points, the DEM data and
extent, and the image the ground control points correspond to, as an
Image object</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~GCPs._dem</strong> (<em>list</em>) – DEM file path</p></li>
<li><p><strong>~GCPs._gcpImage</strong> (<em>arr</em>) – Image that GCPs were defined in</p></li>
<li><p><strong>~GCPs._gcpxyz</strong> (<em>list</em>) – XYZ positions of GCPs</p></li>
<li><p><strong>~GCPs._gcpuv</strong> (<em>list</em>) – UV positions of GCPs</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.GCPs.getDEM">
<span class="sig-name descname"><span class="pre">getDEM</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.GCPs.getDEM" title="Permalink to this definition"></a></dt>
<dd><p>Return the dem object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.GCPs.getGCPs">
<span class="sig-name descname"><span class="pre">getGCPs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.GCPs.getGCPs" title="Permalink to this definition"></a></dt>
<dd><p>Return the world and image GCPs</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.GCPs.getImage">
<span class="sig-name descname"><span class="pre">getImage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.GCPs.getImage" title="Permalink to this definition"></a></dt>
<dd><p>Return the GCP reference image.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="CamEnv.TestCamEnv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">TestCamEnv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.TestCamEnv" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="CamEnv.TestCamEnv.test_getRotation">
<span class="sig-name descname"><span class="pre">test_getRotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.TestCamEnv.test_getRotation" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.calibrateImages">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">calibrateImages</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imageFiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.calibrateImages" title="Permalink to this definition"></a></dt>
<dd><p>Function for calibrating a camera from a set of input calibration
images. Calibration is performed using OpenCV’s chessboard calibration
functions. Input images (imageFile) need to be of a chessboard with
regular dimensions and a known number of corner features (xy).
Please note that OpenCV’s calibrateCamera function is incompatible
between different versions of OpenCV. Included here is the function
for version 3. Please see OpenCV’s documentation for older versions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imageFiles</strong> (<em>list</em>) – List of image file names</p></li>
<li><p><strong>xy</strong> (<em>list</em>) – Chessboard corner dimensions [rows, columns]</p></li>
<li><p><strong>refine</strong> (<em>int</em><em>, </em><em>optional</em>) – OpenCV camera model refinement method - cv2.CALIB_FIX_PRINCIPAL_POINT
(fix principal point), cv2.CALIB_FIX_ASPECT_RATIO (Fix aspect ratio),
cv2.CALIB_FIX_FOCAL_LENGTH (Fix focal length), cv2.CALIB_FIX_INTRINSIC
(Fix camera model), cv2.CALIB_FIX_K1…6 (Fix radial coefficient 1-6),
cv2.CALIB_FIX_TANGENT_DIST (Fix tangential coefficients),
cv2.CALIB_USE_INTRINSIC_GUESS (Use initial intrinsic values),
cv2.CALIB_ZERO_TANGENT_DIST (Set tangential distortion coefficients to
zero), cv2.CALIB_RATIONAL_MODEL (Calculate radial distortion coefficients
k4, k5, and k6) (default=None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list containing the camera intrinsic matrix (arr), and tangential (arr)
and radial distortion coefficents (arr), and the Camera calibration error
(int)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr/list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.computeResidualsUV">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">computeResidualsUV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">GCPxyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">GCPuv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refimg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'YPR'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.computeResidualsUV" title="Permalink to this definition"></a></dt>
<dd><p>Function for computing the pixel difference between GCP image points
and GCP projected XYZ points. This function is used in the optimisation
function (optimiseCamera), with parameters for optimising defined in the
first variable and stable parameters defined in the second. If no
optimisable parameters are given and the optimise flag is set to None then
residuals are computed for the original parameters (i.e. no optimisation)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>arr</em>) – Optimisable parameters, given as a 1-D array of shape (m, )</p></li>
<li><p><strong>stable</strong> (<em>list</em>) – Stable parameters that will not be optimised</p></li>
<li><p><strong>GCPxyz</strong> (<em>arr</em>) – GCPs in scene space (x,y,z)</p></li>
<li><p><strong>GCPuv</strong> (<em>arr</em>) – GCPs in image space (u,v)</p></li>
<li><p><strong>refimg</strong> (<em>str/arr/PyTrx.Images.CamImage</em>) – Reference image, given as a CamImage object, file path string, or image
array</p></li>
<li><p><strong>optimise</strong> (<em>str</em>) – Flag denoting which variables will be optimised: YPR (camera pose only),
INT (internal camera parameters), EXT (external camera parameters), LOC
(all parameters except camera location), or ALL (all projection
parameters)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>residual</strong> – Pixel difference between UV and projected XYZ position of each GCP</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.computeResidualsXYZ">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">computeResidualsXYZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">GCPxyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">GCPuv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.computeResidualsXYZ" title="Permalink to this definition"></a></dt>
<dd><p>Function for computing the pixel difference between GCP image points
and GCP projected XYZ points. This function is used in the optimisation
function (optimiseCamera), with parameters for optimising defined in the
first variable and stable parameters defined in the second. If no
optimisable parameters are given and the optimise flag is set to None then
residuals are computed for the original parameters (i.e. no optimisation)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>arr</em>) – Optimisable parameters, given as a 1-D array of shape (m, )</p></li>
<li><p><strong>stable</strong> (<em>list</em>) – Stable parameters that will not be optimised</p></li>
<li><p><strong>GCPxyz</strong> (<em>arr</em>) – GCPs in scene space (x,y,z)</p></li>
<li><p><strong>GCPuv</strong> (<em>arr</em>) – GCPs in image space (u,v)</p></li>
<li><p><strong>refimg</strong> (<em>str/arr/PyTrx.Images.CamImage</em>) – Reference image, given as a CamImage object, file path string, or image
array</p></li>
<li><p><strong>optimise</strong> (<em>str</em>) – Flag denoting which variables will be optimised: YPR (camera pose only),
INT (internal camera parameters), EXT (external camera parameters), LOC
(all parameters except camera location), or ALL (all projection
parameters)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>residual</strong> – Array denoting pixel difference between UV and projected XYZ position of
each GCP</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.constructDEM">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">constructDEM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dempath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">densefactor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.constructDEM" title="Permalink to this definition"></a></dt>
<dd><p>Construct DEM from a given file path and densification factor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dempath</strong> (<em>str</em>) – DEM filepath</p></li>
<li><p><strong>densefactor</strong> (<em>int</em>) – Densification factor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dem</strong> – DEM object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>PyTrx.DEM.ExplicitRaster</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.getRotation">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">getRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">camDirection</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.getRotation" title="Permalink to this definition"></a></dt>
<dd><p>Calculates camera rotation matrix calculated from view direction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>camDirection</strong> (<em>arr</em>) – Camera pose (yaw,pitch,roll)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – Rotation matrix as array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.optimiseCamera">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">optimiseCamera</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projvars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">GCPxyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">GCPuv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.optimiseCamera" title="Permalink to this definition"></a></dt>
<dd><p>Optimise camera parameters using the pixel differences between a set
of image GCPs and projected XYZ GCPs. The optimisation routine adopts the
least_square function in scipy’s optimize tools, using either the Trust
Region Reflective algorithm, the dogleg algorithm or the
Levenberg-Marquardt algorithm to refine a set group of projection
parameters - camera pose only, the internal camera parameters (i.e. radial
distortion, tangential distortion, focal length, principal point), the
external camera parameters (i.e. camera location, camera pose), or all
projection parameters (i.e. camera location, camera pose, radial
distortion, tangential distortion, focal length, principal point).
The Trust Region Reflective algorithm is generally a robust method, ideal
for solving many variables (default). The Dogleg algorithm is ideal for
solving few variables. The Levenberg-Margquardt algorithm is the most
efficient method, ideal for solving few variables.
Pixel differences between a set of image GCPs and projected XYZ GCPs are
calculated and refined within the optimisation function, performing
iterations until an optimum solution is reached. A new set of optimised
projection parameters are returned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optimise</strong> (<em>str</em>) – Flag denoting which variables will be optimised: YPR (camera pose only),
INT (internal camera parameters), EXT (external camera parameters),
LOC (all parameters except camera location), or ALL (all projection
parameters)</p></li>
<li><p><strong>projvars</strong> (<em>list</em>) – Projection parameters [camera location, camera pose, radial distortion,
tangential distortion, focal length, principal point, reference image]</p></li>
<li><p><strong>GCPuv</strong> (<em>arr</em>) – UV positions for GCPs, as shape (m, 2)</p></li>
<li><p><strong>optmethod</strong> (<em>str</em><em>, </em><em>optional</em>) – Optimisation method: ‘trf’ (Trust Region Reflective algorithm),
‘dogbox’ (dogleg algorithm), or ‘lm’ (Levenberg-Marquardt algorithm)
(default=’trf’)</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Flag denoting whether plot of residuals should be shown</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>projvars1</strong> – A list containing the optimised projection parameters. If optimisation
fails then None is returned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list                                          .</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.projectUV">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">projectUV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.projectUV" title="Permalink to this definition"></a></dt>
<dd><p>Inverse project image coordinates (uv) to xyz world coordinates
using inverse projection variables (set using setProjection function).
This function is primarily adopted from the ImGRAFT projection function
found in camera.m: uv,depth,inframe=cam.project(xyz)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uv</strong> (<em>arr</em>) – Pixel coordinates in image</p></li>
<li><p><strong>invprojvars</strong> (<em>list</em>) – Inverse projection variables [X,Y,Z,uv0]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xyz</strong> – World coordinates of inputted pixel coordinates</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.projectXYZ">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">projectXYZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">camloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camdirection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foclen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camcen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refimg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.projectXYZ" title="Permalink to this definition"></a></dt>
<dd><p>Project the xyz world coordinates into the corresponding image
coordinates (uv). This is primarily executed using the ImGRAFT projection
function found in camera.m: uv,depth,inframe=cam.project(xyz)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>camloc</strong> (<em>arr</em>) – Camera location [X,Y,Z]</p></li>
<li><p><strong>camdirection</strong> (<em>arr</em>) – Camera pose (yaw, pitch, roll)</p></li>
<li><p><strong>radial</strong> (<em>arr</em>) – Radial distortion coefficients</p></li>
<li><p><strong>tangen</strong> (<em>arr</em>) – Tangential distortion coefficients</p></li>
<li><p><strong>foclen</strong> (<em>arr</em>) – Camera focal length</p></li>
<li><p><strong>camcen</strong> (<em>arr</em>) – Camera principal point</p></li>
<li><p><strong>refimg</strong> (<em>arr</em>) – Reference image (function only uses the image dimensions)</p></li>
<li><p><strong>xyz</strong> (<em>arr</em>) – world coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>uv</strong> (<em>arr</em>) – Pixel coordinates in image</p></li>
<li><p><strong>depth</strong> (<em>int</em>) – View depth</p></li>
<li><p><strong>inframe</strong> (<em>arr</em>) – Boolean vector containing whether each projected 3D point is inside the
frame</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CamEnv.setProjection">
<span class="sig-prename descclassname"><span class="pre">CamEnv.</span></span><span class="sig-name descname"><span class="pre">setProjection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camdir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foclen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camcen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refimg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viewshed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CamEnv.setProjection" title="Permalink to this definition"></a></dt>
<dd><p>Set the inverse projection variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – DEM object</p></li>
<li><p><strong>camloc</strong> (<em>arr</em>) – Camera location (X,Y,Z)</p></li>
<li><p><strong>camdir</strong> (<em>arr</em>) – Camera pose [yaw, pitch, roll]</p></li>
<li><p><strong>radial</strong> (<em>arr</em>) – Radial distortion coefficients</p></li>
<li><p><strong>tangen</strong> (<em>arr</em>) – Tangential distortion coefficients</p></li>
<li><p><strong>foclen</strong> (<em>arr</em>) – Camera focal length</p></li>
<li><p><strong>camcen</strong> (<em>arr</em>) – Camera principal point</p></li>
<li><p><strong>refimg</strong> (<em>arr</em>) – Reference image (function only uses the image dimensions)</p></li>
<li><p><strong>viewshed</strong> (<em>bool</em>) – Flag to denote if viewshed from camera should be determined before
projection</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>invProjVars</strong> – Inverse projection coefficients [X,Y,Z,uv0]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-DEM">
<span id="dem-module"></span><h2>DEM module<a class="headerlink" href="#module-DEM" title="Permalink to this headline"></a></h2>
<p>The DEM module contains functionality for handling DEM data and implementing
this data into the PyTrx.CamEnv.CamEnv object class.</p>
<dl class="py function">
<dt class="sig sig-object py" id="DEM.DEM_FromMat">
<span class="sig-prename descclassname"><span class="pre">DEM.</span></span><span class="sig-name descname"><span class="pre">DEM_FromMat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.DEM_FromMat" title="Permalink to this definition"></a></dt>
<dd><p>Function for loading a DEM array from a Matlab (.mat) file containing
separate X, Y, Z matrices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matfile</strong> (<em>str</em>) – DEM .mat filepath</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A DEM object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>PyTrx.DEM.ExplicitRaster</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DEM.DEM_FromTiff">
<span class="sig-prename descclassname"><span class="pre">DEM.</span></span><span class="sig-name descname"><span class="pre">DEM_FromTiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tiffFile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.DEM_FromTiff" title="Permalink to this definition"></a></dt>
<dd><p>Function for loading a DEM array from a .tiff file containing
raster-formatted data. The tiff data importing is handled by GDAL</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tiffFile</strong> (<em>str</em>) – DEM .tif filepath</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A DEM object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>PyTrx.DEM.ExplicitRaster</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="DEM.ExplicitRaster">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">DEM.</span></span><span class="sig-name descname"><span class="pre">ExplicitRaster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to represent a numeric Raster with explicit XY cell referencing
in each grid cell</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~ExplicitRaster._data</strong> (<em>arr</em>) – DEM data array</p></li>
<li><p><strong>~ExplicitRaster._nodata</strong> (<em>float</em>) – Nodata value</p></li>
<li><p><strong>~ExplicitRaster._extents</strong> (<em>list</em>) – DEM extent [X0, X1, Y0, Y1]</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.densify">
<span class="sig-name descname"><span class="pre">densify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">densefac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.densify" title="Permalink to this definition"></a></dt>
<dd><p>Function to densify the DEM array by a given densification factor.
The array is multiplied by the given densification factor and then
subsequently values are interpolated using the SciPy function
RectBivariateSpline. The densification factor is set to 2 by default,
meaning that the size of the DEM array is doubled</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>densefac</strong> (<em>int</em>) – Densification factor</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Densified DEM</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>PyTrx.DEM.ExplicitRaster</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getCols">
<span class="sig-name descname"><span class="pre">getCols</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getCols" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of columns in the DEM data array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getData">
<span class="sig-name descname"><span class="pre">getData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getData" title="Permalink to this definition"></a></dt>
<dd><p>Return DEM data. XYZ dimensions can be individually called with the
dim input variable (integer: 0, 1, or 2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Dimension to retrieve (0, 1, or 2), default to None</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>DEM dimension as array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getExtent">
<span class="sig-name descname"><span class="pre">getExtent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getExtent" title="Permalink to this definition"></a></dt>
<dd><p>Return DEM extent</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getNoData">
<span class="sig-name descname"><span class="pre">getNoData</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getNoData" title="Permalink to this definition"></a></dt>
<dd><p>Return fill value for no data in DEM array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getRows">
<span class="sig-name descname"><span class="pre">getRows</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getRows" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of rows in the DEM data array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getShape">
<span class="sig-name descname"><span class="pre">getShape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getShape" title="Permalink to this definition"></a></dt>
<dd><p>Return the shape of the DEM data array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getZ">
<span class="sig-name descname"><span class="pre">getZ</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getZ" title="Permalink to this definition"></a></dt>
<dd><p>Return height (Z) data of DEM</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.getZcoord">
<span class="sig-name descname"><span class="pre">getZcoord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.getZcoord" title="Permalink to this definition"></a></dt>
<dd><p>Return height (Z) at a given XY coordinate in DEM</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>int</em>) – X coordinate</p></li>
<li><p><strong>y</strong> (<em>int</em>) – Y coordinate</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>DEM Z value for given coordinate</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.reportDEM">
<span class="sig-name descname"><span class="pre">reportDEM</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.reportDEM" title="Permalink to this definition"></a></dt>
<dd><p>Self reporter for DEM class object. Returns the number of rows and
columns in the array, how NaN values in the array are filled, and the
data extent coordinates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.ExplicitRaster.subset">
<span class="sig-name descname"><span class="pre">subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.ExplicitRaster.subset" title="Permalink to this definition"></a></dt>
<dd><p>Return a specified subset of the DEM array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cmin</strong> (<em>int</em>) – Column minimum extent</p></li>
<li><p><strong>cmax</strong> (<em>int</em>) – Column maximum extent</p></li>
<li><p><strong>rmin</strong> (<em>int</em>) – Row minimum extent</p></li>
<li><p><strong>rmax</strong> (<em>int</em>) – Row maximum extent</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Subset of DEM</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>PyTrx.DEM.ExplicitRaster</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="DEM.TestDEM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">DEM.</span></span><span class="sig-name descname"><span class="pre">TestDEM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.TestDEM" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="DEM.TestDEM.test_ExplicitRaster">
<span class="sig-name descname"><span class="pre">test_ExplicitRaster</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.TestDEM.test_ExplicitRaster" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.TestDEM.test_getRows">
<span class="sig-name descname"><span class="pre">test_getRows</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.TestDEM.test_getRows" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.TestDEM.test_subset">
<span class="sig-name descname"><span class="pre">test_subset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.TestDEM.test_subset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="DEM.TestDEM.test_voxelviewshed">
<span class="sig-name descname"><span class="pre">test_voxelviewshed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DEM.TestDEM.test_voxelviewshed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DEM.load_DEM">
<span class="sig-prename descclassname"><span class="pre">DEM.</span></span><span class="sig-name descname"><span class="pre">load_DEM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">demfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.load_DEM" title="Permalink to this definition"></a></dt>
<dd><p>Function for loading DEM data from different file types, which is
automatically detected. Recognised file types: .mat and .tif</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>demfile</strong> (<em>str</em>) – DEM filepath</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>DEM object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>PyTrx.DEM.ExplicitRaster</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DEM.voxelviewshed">
<span class="sig-prename descclassname"><span class="pre">DEM.</span></span><span class="sig-name descname"><span class="pre">voxelviewshed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viewpoint</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DEM.voxelviewshed" title="Permalink to this definition"></a></dt>
<dd><p>Calculate a viewshed over a DEM from a given viewpoint in the DEM scene.
This function is based on the viewshed function (voxelviewshed.m) available
in ImGRAFT. The ImGRAFT voxelviewshed.m script is available at:
<a class="reference external" href="http://github.com/grinsted/ImGRAFT/blob/master/voxelviewshed.m">http://github.com/grinsted/ImGRAFT/blob/master/voxelviewshed.m</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – DEM object</p></li>
<li><p><strong>viewpoint</strong> (<em>list</em>) – 3-element vector specifying the viewpoint</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vis</strong> – Boolean visibility matrix (which is the same size as dem)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-FileHandler">
<span id="filehandler-module"></span><h2>FileHandler module<a class="headerlink" href="#module-FileHandler" title="Permalink to this headline"></a></h2>
<p>Th FileHandler module contains all the functions called by a PyTrx object to
load and export data.</p>
<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.checkMatrix">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">checkMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.checkMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Function to support the calibrate function. Checks and converts the
intrinsic matrix to the correct format for calibration with OpenCV</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>arr</em>) – Inputted matrix for checking</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mat</strong> – Validated matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.importAreaData">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">importAreaData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pxfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.importAreaData" title="Permalink to this definition"></a></dt>
<dd><p>Import xyz and px data from text files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzfile</strong> (<em>str</em>) – File directory to xyz coordinates</p></li>
<li><p><strong>pxfile</strong> (<em>str</em>) – File directory to uv coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>areas</strong> – Coordinates and areas of detected areas</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.importAreaFile">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">importAreaFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.importAreaFile" title="Permalink to this definition"></a></dt>
<dd><p>Import pixel polygon data from text file and compute pixel extents</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – Path to the text file containing the UV coordinate data</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Integer denoting the number of dimensions in coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>areas</strong> – UV coordinates for polygons and pixel areas for polygons</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.importLineData">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">importLineData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pxfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.importLineData" title="Permalink to this definition"></a></dt>
<dd><p>Import xyz and px data from text files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzfile</strong> (<em>str</em>) – File directory to xyz coordinates</p></li>
<li><p><strong>pxfile</strong> (<em>str</em>) – File directory to uv coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>lines</strong> – Coordinates and lengths of detected lines</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.importLineFile">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">importLineFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.importLineFile" title="Permalink to this definition"></a></dt>
<dd><p>Import XYZ line data from text file and compute line lengths</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – Path to the text file containing the XYZ coordinate data</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Number of dimensions in point coordinates i.e. 2 or 3</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>lines</strong> – List containing line coordinates and lengths</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.lineSearch">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">lineSearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lineList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.lineSearch" title="Permalink to this definition"></a></dt>
<dd><p>Function to supplement the readCalib function. Given an input parameter
to search within the file, this will return the line numbers of the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lineList</strong> (<em>list</em>) – List of strings within a file line</p></li>
<li><p><strong>search</strong> (<em>str</em>) – Target keyword to search for</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>datalines</strong> – Line numbers with keyword match</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.readCalib">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">readCalib</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paramList</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.readCalib" title="Permalink to this definition"></a></dt>
<dd><p>Function to find camera calibrations from a file given a list or
Matlab file containing the required parameters. Returns the parameters as a
dictionary object. Compatible file structures: 1) .txt file
(“RadialDistortion [k1,k2,k3…k8], TangentialDistortion [p1,p2],
IntrinsicMatrix [fx 0. 0.][s fy 0.][cx cy 1] End”); 2) .mat file
(Camera calibration file output from the Matlab Camera Calibration App
(available in the Computer Vision Systems toolbox)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fileName</strong> (<em>str</em>) – File directory for calibration file</p></li>
<li><p><strong>paramList</strong> (<em>list</em>) – List of strings denoting keywords to look for in calibration file</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>calib</strong> – Calibration parameters denoted by keywords</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.readGCPs">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">readGCPs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileName</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.readGCPs" title="Permalink to this definition"></a></dt>
<dd><p>Function to read ground control points from a .txt file. The data in the
file is referenced to under a header line. Data is appended by skipping the
header line and finding the world and image coordinates from each line</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fileName</strong> (<em>str</em>) – File path directory for GCP file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>world</strong> (<em>arr</em>) – GCPs in xyz coordinates</p></li>
<li><p><strong>image</strong> (<em>arr</em>) – GCPs in image coordinates</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.readImg">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">readImg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.readImg" title="Permalink to this definition"></a></dt>
<dd><p>Function to prepare an image by opening, equalising, converting to
either grayscale or a specified band, then returning a copy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>str</em>) – Image file path directory</p></li>
<li><p><strong>band</strong> (<em>str</em>) – Desired band output - ‘R’: red band; ‘B’: blue band; ‘G’: green band;
‘L’: grayscale (default=’L’)</p></li>
<li><p><strong>equal</strong> (<em>bool</em>) – Flag to denote if histogram equalisation should be applied (default=True)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bw</strong> – Image array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.readMask">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">readMask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">writeMask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.readMask" title="Permalink to this definition"></a></dt>
<dd><p>Function to create a mask for point seeding using PIL to rasterize
polygon. The mask is manually defined by the user using the pyplot ginput
function. This subsequently returns the manually defined area as a .jpg
mask. The writeMask file path is used to either open the existing mask at
that path or to write the generated mask to this path</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Image to define mask in</p></li>
<li><p><strong>writeMask</strong> (<em>str</em><em>, </em><em>optional</em>) – File destination that mask output is written to, default to None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>myMask</strong> – Array defining the image mask</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.readMatrixDistortion">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">readMatrixDistortion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.readMatrixDistortion" title="Permalink to this definition"></a></dt>
<dd><p>Function to support the calibrate function. Returns the intrinsic matrix
and distortion parameters required for calibration from a given file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>str</em>) – Directory of calibration file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>intrMat</strong> (<em>arr</em>) – Intrinsic matrix as a 3x3 array, including focal length, principal point,
and skew</p></li>
<li><p><strong>tanDis</strong> (<em>arr</em>) – Tangential distortion values (p1, p2)</p></li>
<li><p><strong>radDis</strong> (<em>arr</em>) – Radial distortion values (k1, k2… k6)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.returnData">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">returnData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.returnData" title="Permalink to this definition"></a></dt>
<dd><p>Function to supplement the importCalibration function. Given the line
numbers of the parameter data (the ouput of the lineSearch function), this
will return the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lines</strong> (<em>list</em>) – Given line numbers to extract data from</p></li>
<li><p><strong>data</strong> (<em>list</em>) – Raw line data</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>D</strong> – Extracted data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeAreaCoords">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeAreaCoords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pxpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyzpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pxdestination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyzdestination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeAreaCoords" title="Permalink to this definition"></a></dt>
<dd><p>Write UV and XYZ area coordinates to text files. These file types are
compatible with the importing tools (importAreaPX, importAreaXYZ)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzarea</strong> (<em>list</em>) – XYZ areas</p></li>
<li><p><strong>xyzpts</strong> (<em>list</em>) – XYZ coordinates</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – Image names</p></li>
<li><p><strong>pxdestination</strong> (<em>str</em>) – File directory where UV coordinates will be written to</p></li>
<li><p><strong>xyzdestination</strong> (<em>str</em>) – File directory where XYZ coordinates will be written to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeAreaFile">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeAreaFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pxareas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyzareas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeAreaFile" title="Permalink to this definition"></a></dt>
<dd><p>Write UV and XYZ areas to csv file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxarea</strong> (<em>list</em>) – Pixel extents</p></li>
<li><p><strong>xyzarea</strong> (<em>list</em>) – XYZ areas</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – Image names</p></li>
<li><p><strong>destination</strong> (<em>str</em>) – File directory where csv file will be written to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeAreaSHP">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeAreaSHP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileDirectory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeAreaSHP" title="Permalink to this definition"></a></dt>
<dd><p>Write OGR real polygon areas (from ALL images) to file in a .shp
file type that is compatible with ESRI mapping software</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzpts</strong> (<em>list</em>) – XYZ coordinates for polygons</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – Image name</p></li>
<li><p><strong>fileDirectory</strong> (<em>str</em>) – Destination that shapefiles will be written to</p></li>
<li><p><strong>projection</strong> (<em>int/str</em><em>, </em><em>optional</em>) – Coordinate projection that the shapefile will exist in. This can either
be an ESPG number (expressed as an integer) or a well-known geographical
coordinate system (expressed as a string). Well-known geographical
coordinate systems are: ‘WGS84’, ‘WGS72’, NAD83’ or ‘EPSG:n’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeCalibFile">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeCalibFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intrMat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tanDis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radDis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeCalibFile" title="Permalink to this definition"></a></dt>
<dd><p>Write camera calibration data to .txt file, including camera matrix, and
radial and tangential distortion parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intrMat</strong> (<em>arr</em>) – Intrinsic camera matrix</p></li>
<li><p><strong>tanDis</strong> (<em>arr</em>) – Tangential distortion parameters</p></li>
<li><p><strong>radDis</strong> (<em>arr</em>) – Radial distortion parameters</p></li>
<li><p><strong>fname</strong> (<em>str</em>) – Directory to write file to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeHomogFile">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeHomogFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">homog</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeHomogFile" title="Permalink to this definition"></a></dt>
<dd><p>Function to write all homography data from a given timeLapse sequence to
.csv file. Data is formatted as sequential columns containing the following
information: Image pair 1 name, Image pair 2 name, Homography matrix (i.e.
all values in the 3x3 matrix), Number of features tracked, X mean
displacement, Y mean displacement, X standard deviation, Y standard
deviation, Mean error magnitude, Mean homographic displacement, and
Signal-to-noise ratio</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>homog</strong> (<em>list</em>) – Homography [mtx, im0pts, im1pts, ptserr, homogerr]</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – List of image names</p></li>
<li><p><strong>fname</strong> (<em>str</em>) – Directory for file to be written to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeLineCoords">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeLineCoords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uvpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyzpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pxdestination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyzdestination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeLineCoords" title="Permalink to this definition"></a></dt>
<dd><p>Write UV and XYZ line coordinates to text file. These file types are
compatible with the importing tools (importLinePX, importLineXYZ)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uvpts</strong> (<em>list</em>) – Pixel coordinates</p></li>
<li><p><strong>xyzpts</strong> (<em>list</em>) – XYZ coordinates</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – Image names</p></li>
<li><p><strong>pxdestination</strong> (<em>str</em>) – File directory where UV coordinates will be written to</p></li>
<li><p><strong>xyzdestination</strong> (<em>str</em>) – File directory where XYZ coordinates will be written to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeLineFile">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeLineFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pxline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyzline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeLineFile" title="Permalink to this definition"></a></dt>
<dd><p>Write UV and XYZ line lengths to csv file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pxline</strong> (<em>list</em>) – Pixel line lengths</p></li>
<li><p><strong>xyzline</strong> (<em>list</em>) – XYZ line lengths</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – Image names</p></li>
<li><p><strong>destination</strong> (<em>str</em>) – File directory where output will be written to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeLineSHP">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeLineSHP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileDirectory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeLineSHP" title="Permalink to this definition"></a></dt>
<dd><p>Write OGR real line features (from ALL images) to file in a .shp
file type that is compatible with ESRI mapping software</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzpts</strong> (<em>list</em>) – XYZ coordinates for polygons</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – Image name</p></li>
<li><p><strong>fileDirectory</strong> (<em>str</em>) – Destination that shapefiles will be written to</p></li>
<li><p><strong>projection</strong> (<em>int/str</em><em>, </em><em>optional</em>) – Coordinate projection that the shapefile will exist in. This can either
be an ESPG number (expressed as an integer) or a well-known geographical
coordinate system (expressed as a string). Well-known geographical
coordinate systems are: ‘WGS84’, ‘WGS72’, NAD83’ or ‘EPSG:n’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeVeloFile">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeVeloFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzvel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uvvel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homog</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeVeloFile" title="Permalink to this definition"></a></dt>
<dd><p>Function to write all velocity data from a given timeLapse sequence to
.csv file. Data is formatted as sequential columns containing the following
information: Image pair 1 name, Image pair 2 name, Average xyz velocity,
Number of features tracked, Average pixel velocity, Homography residual
mean error (RMS), and Signal-to-noise ratio</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzvel</strong> (<em>list</em>) – XYZ velocities</p></li>
<li><p><strong>uvvel</strong> (<em>list</em>) – Pixel velocities</p></li>
<li><p><strong>homog</strong> (<em>list</em>) – Homography [mtx, im0pts, im1pts, ptserr, homogerr]</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – List of image names</p></li>
<li><p><strong>fname</strong> (<em>str</em>) – Filename for output file. File destination can also specified</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FileHandler.writeVeloSHP">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">writeVeloSHP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzvel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyzerr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyz0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileDirectory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FileHandler.writeVeloSHP" title="Permalink to this definition"></a></dt>
<dd><p>Write OGR real velocity points (from ALL images) to file in a .shp
file type that is compatible with ESRI mapping software</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzvel</strong> (<em>list</em>) – XYZ velocities</p></li>
<li><p><strong>xyz0</strong> (<em>list</em>) – XYZ pt0</p></li>
<li><p><strong>imn</strong> (<em>list</em>) – Image name</p></li>
<li><p><strong>fileDirectory</strong> (<em>str</em>) – Destination that shapefiles will be written to</p></li>
<li><p><strong>projection</strong> (<em>int/str</em><em>, </em><em>optional</em>) – Coordinate projection that the shapefile will exist in. This can either
be an ESPG number (expressed as an integer) or a well-known geographical
coordinate system (expressed as a string). Well-known geographical
coordinate systems are: ‘WGS84’, ‘WGS72’, NAD83’ or ‘EPSG:n’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-Images">
<span id="images-module"></span><h2>Images module<a class="headerlink" href="#module-Images" title="Permalink to this headline"></a></h2>
<p>The Images module contains the object-constructors and functions for: (1)
Importing and handling image data, specifically RBG, one-band (R, B or G), and
grayscale images; and (2) Handling image sequences (i.e. a set of multiple
images).</p>
<dl class="py class">
<dt class="sig sig-object py" id="Images.CamImage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Images.</span></span><span class="sig-name descname"><span class="pre">CamImage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imagePath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class representing a raw single band (optical RGB or greyscale). This
CamImage object is used in subsequent timelapse analysis. The object
contains the image data, image path, image dimensions and timestamp
(derived from the image Exif data, if available).
Optionally the user can specify whether the red, blue or green values
should be used, or whether the images should be converted to grey scale
which is the default. No image calibration is undertaken at this point.
The default grayscale band option (‘l’) applies an equalization filter
on the image whereas the RGB splits are raw RGB. This could be modified
to permit more sophisticated settings of RGB combinations and/or
filters with file reading</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~CamImage._imageGood</strong> (<em>bool</em>) – Valid image filepath flag</p></li>
<li><p><strong>~CamImage._band</strong> (<em>str</em>) – Image band (‘R’,’G’,’B’ or ‘L’)</p></li>
<li><p><strong>~CamImage._equal</strong> (<em>bool</em>) – Histogram equalisation flag</p></li>
<li><p><strong>~CamImage._imageArray</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>~CamImage._image</strong> (<em>PIL.Image</em>) – Image object</p></li>
<li><p><strong>~CamImage._imsize</strong> (<em>list</em>) – Image height and width</p></li>
<li><p><strong>~CamImage._timestamp</strong> (<em>datetime.datetime</em>) – timestamp from image EXIF info</p></li>
<li><p><strong>~CamImage._impath</strong> (<em>str</em>) – Image filepath</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.changeBand">
<span class="sig-name descname"><span class="pre">changeBand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">band</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.changeBand" title="Permalink to this definition"></a></dt>
<dd><p>Change the band you want the image to represent (‘r’, ‘b’, ‘g’ or
‘l’)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>band</strong> (<em>str</em>) – Image band (‘r’, ‘b’, ‘g’, or ‘l’)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.clearAll">
<span class="sig-name descname"><span class="pre">clearAll</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.clearAll" title="Permalink to this definition"></a></dt>
<dd><p>Clear memory of all retained data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.clearImage">
<span class="sig-name descname"><span class="pre">clearImage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.clearImage" title="Permalink to this definition"></a></dt>
<dd><p>Clear memory of image data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.clearImageArray">
<span class="sig-name descname"><span class="pre">clearImageArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.clearImageArray" title="Permalink to this definition"></a></dt>
<dd><p>Clear memory of image array data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getExif">
<span class="sig-name descname"><span class="pre">getExif</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getExif" title="Permalink to this definition"></a></dt>
<dd><p>Return the exif image size and time stamp data from the image. Image
size is returned as a string (height, width). The time stamp is
returned as a Python datetime object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>imsize</strong> (<em>list</em>) – Image height, image width</p></li>
<li><p><strong>timestamp</strong> (<em>datetime.datetime</em>) – Image time stamp</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImage">
<span class="sig-name descname"><span class="pre">getImage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImage" title="Permalink to this definition"></a></dt>
<dd><p>Return the image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImageArray">
<span class="sig-name descname"><span class="pre">getImageArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImageArray" title="Permalink to this definition"></a></dt>
<dd><p>Return the image as an array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImageCorr">
<span class="sig-name descname"><span class="pre">getImageCorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cameraMatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distortP</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImageCorr" title="Permalink to this definition"></a></dt>
<dd><p>Return the image array that is corrected for the specificied
camera matrix and distortion parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cameraMatrix</strong> (<em>arr</em>) – Intrinsic camera matrix</p></li>
<li><p><strong>distortP</strong> (<em>arr</em>) – Lens distortion parameters</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>corr_image</strong> – Image corrected for image distortion (arr)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImageEnhance">
<span class="sig-name descname"><span class="pre">getImageEnhance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImageEnhance" title="Permalink to this definition"></a></dt>
<dd><p>Return enhanced image using PyTrx.Images.enhanceImg function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diff</strong> (<em>str</em>) – Inputted as either ‘light or ‘dark’, signifying the intensity of the
image pixels. ‘light’ increases the intensity such that dark pixels
become much brighter and bright pixels become slightly brighter.
‘dark’ decreases the intensity such that dark pixels become much
darker and bright pixels become slightly darker</p></li>
<li><p><strong>phi</strong> (<em>int</em>) – Defines the intensity of all pixel values</p></li>
<li><p><strong>theta</strong> (<em>int</em>) – Defines the number of “colours” in the image, e.g. 3 signifies that
all the pixels will be grouped into one of three pixel values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>image1</strong> – Enhanced image</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImageName">
<span class="sig-name descname"><span class="pre">getImageName</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImageName" title="Permalink to this definition"></a></dt>
<dd><p>Return image name</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImagePath">
<span class="sig-name descname"><span class="pre">getImagePath</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImagePath" title="Permalink to this definition"></a></dt>
<dd><p>Return the file path of the image</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImageSize">
<span class="sig-name descname"><span class="pre">getImageSize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImageSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the size of the image (which is obtained from the image Exif
information)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImageTime">
<span class="sig-name descname"><span class="pre">getImageTime</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImageTime" title="Permalink to this definition"></a></dt>
<dd><p>Return the time of the image (which is obtained from the image Exif
information)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.getImageType">
<span class="sig-name descname"><span class="pre">getImageType</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.getImageType" title="Permalink to this definition"></a></dt>
<dd><p>Return the image file type</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.imageGood">
<span class="sig-name descname"><span class="pre">imageGood</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.imageGood" title="Permalink to this definition"></a></dt>
<dd><p>Return image file path status</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.CamImage.reportCamImageData">
<span class="sig-name descname"><span class="pre">reportCamImageData</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.CamImage.reportCamImageData" title="Permalink to this definition"></a></dt>
<dd><p>Report image data (file path, image size and datetime)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Images.ImageSequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Images.</span></span><span class="sig-name descname"><span class="pre">ImageSequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imageList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.ImageSequence" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to model a raw collection of CamImage objects, which can
subsequently be used for making photogrammetric measurements from</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~ImageSequence._band</strong> (<em>str</em>) – Image band (‘r’, ‘b’, ‘g’, or ‘l’)</p></li>
<li><p><strong>~ImageSequence._equal</strong> (<em>bool</em>) – Histogram equalisation flag</p></li>
<li><p><strong>~ImageSequence._imageList</strong> (<em>list/str</em>) – Image filepaths, glob folder path, or list of PyTrx.Image.CamImage
objects</p></li>
<li><p><strong>~ImageSequence._imageSet</strong> (<em>list</em>) – List of PyTrx.Image.CamImage objects</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Images.ImageSequence.getImageArrNo">
<span class="sig-name descname"><span class="pre">getImageArrNo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.ImageSequence.getImageArrNo" title="Permalink to this definition"></a></dt>
<dd><p>Get image array i from image sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<em>int</em>) – Image number in sequence</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>arr</strong> – Image array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.ImageSequence.getImageFileList">
<span class="sig-name descname"><span class="pre">getImageFileList</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.ImageSequence.getImageFileList" title="Permalink to this definition"></a></dt>
<dd><p>Return list of image file paths</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.ImageSequence.getImageNames">
<span class="sig-name descname"><span class="pre">getImageNames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.ImageSequence.getImageNames" title="Permalink to this definition"></a></dt>
<dd><p>Return list of image file names</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.ImageSequence.getImageObj">
<span class="sig-name descname"><span class="pre">getImageObj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.ImageSequence.getImageObj" title="Permalink to this definition"></a></dt>
<dd><p>Get PyTrx.Images.CamImage object i from image sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> (<em>int</em>) – Image number in sequence</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>imo</strong> – Image object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>PyTrx.Images.CamImage</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.ImageSequence.getImages">
<span class="sig-name descname"><span class="pre">getImages</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.ImageSequence.getImages" title="Permalink to this definition"></a></dt>
<dd><p>Return image set (i.e. a sequence of CamImage objects)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Images.ImageSequence.getLength">
<span class="sig-name descname"><span class="pre">getLength</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.ImageSequence.getLength" title="Permalink to this definition"></a></dt>
<dd><p>Return length of image set</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Images.TestImages">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Images.</span></span><span class="sig-name descname"><span class="pre">TestImages</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.TestImages" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="Images.TestImages.test_enhanceImage">
<span class="sig-name descname"><span class="pre">test_enhanceImage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Images.TestImages.test_enhanceImage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Images.enhanceImage">
<span class="sig-prename descclassname"><span class="pre">Images.</span></span><span class="sig-name descname"><span class="pre">enhanceImage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Images.enhanceImage" title="Permalink to this definition"></a></dt>
<dd><p>Change brightness and contrast of image using phi and theta variables.
Change phi and theta values accordingly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Input image array for enhancement</p></li>
<li><p><strong>diff</strong> (<em>str</em>) – Inputted as either ‘light or ‘dark’, signifying the intensity of the
image pixels. ‘light’ increases the intensity such that dark pixels
become much brighter and bright pixels become slightly brighter. ‘dark’
decreases the intensity such that dark pixels become much darker and
bright pixels become slightly darker</p></li>
<li><p><strong>phi</strong> (<em>int</em>) – Defines the intensity of all pixel values</p></li>
<li><p><strong>theta</strong> (<em>int</em>) – Defines the number of “colours” in the image, e.g. 3 signifies that all
the pixels will be grouped into one of three pixel values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>img1</strong> – Enhanced image</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-Line">
<span id="line-module"></span><h2>Line module<a class="headerlink" href="#module-Line" title="Permalink to this headline"></a></h2>
<p>The Line module handles the functionality for obtaining line measurements from
oblique time-lapse imagery. Specifically, this module contains functions for:
(1) Performing manual detection of lines in oblique imagery; and (2)
Determining real-world distances from oblique imagery.</p>
<dl class="py class">
<dt class="sig sig-object py" id="Line.Line">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Line.</span></span><span class="sig-name descname"><span class="pre">Line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imageList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cameraenv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibFlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Line.Line" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#Images.ImageSequence" title="Images.ImageSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Images.ImageSequence</span></code></a></p>
<p>A class for handling lines/distances (e.g. glacier terminus position)
through an image sequence, with methods to manually define pixel lines in
the image plane and georectify them to generate real-world coordinates and
distances. The Line class object primarily inherits from the Area class</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~Line._camEnv</strong> (<em>PyTrx.CamEnv.CamEnv</em>) – Camera environment object</p></li>
<li><p><strong>~Line._calibFlag</strong> (<em>bool</em>) – Image calibration flag</p></li>
<li><p><strong>~Line._hmatrix</strong> (<em>arr</em>) – Homography matrix</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Line.Line.calcManualLines">
<span class="sig-name descname"><span class="pre">calcManualLines</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Line.Line.calcManualLines" title="Permalink to this definition"></a></dt>
<dd><p>Method to manually define pixel lines from an image sequence. The
lines are manually defined by the user on an image plot. Returns the
line pixel coordinates and pixel length</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>lines</strong> – XYZ and UV line lengths and coordinates</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Line.TestLine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Line.</span></span><span class="sig-name descname"><span class="pre">TestLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Line.TestLine" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="Line.TestLine.test_getOGRLine">
<span class="sig-name descname"><span class="pre">test_getOGRLine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Line.TestLine.test_getOGRLine" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Line.calcManualLine">
<span class="sig-prename descclassname"><span class="pre">Line.</span></span><span class="sig-name descname"><span class="pre">calcManualLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmatrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Line.calcManualLine" title="Permalink to this definition"></a></dt>
<dd><p>Manually define a line in a given image to produce XYZ and UV line
length and corresponding coordinates. Lines are defined through user input
by clicking in the interactive image plot. This primarily operates via the
pyplot.ginput function which allows users to define coordinates through
plot interaction. If inverse projection variables are given, XYZ lines
and coordinates are also calculated</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Image array for plotting.</p></li>
<li><p><strong>imn</strong> (<em>str</em>) – Image name</p></li>
<li><p><strong>hmatrix</strong> (<em>arr</em><em>, </em><em>optional</em>) – Homography matrix (default=None)</p></li>
<li><p><strong>invprojvars</strong> (<em>list</em><em>, </em><em>optional</em>) – Inverse projection variables [X,Y,Z,uv0] (default=None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Four list element containing: line length in xyz (list), xyz coordinates
of lines (list), line length in pixels (list), and uvcoordinates of lines
(list)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Line.getOGRLine">
<span class="sig-prename descclassname"><span class="pre">Line.</span></span><span class="sig-name descname"><span class="pre">getOGRLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Line.getOGRLine" title="Permalink to this definition"></a></dt>
<dd><p>Function to construct an OGR line from a set of uv coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pts</strong> (<em>arr</em>) – A series of uv coordinates denoting a line</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>line</strong> – A line object constructed from the input coordinates</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ogr.Geometry</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-Utilities">
<span id="utilities-module"></span><h2>Utilities module<a class="headerlink" href="#module-Utilities" title="Permalink to this headline"></a></h2>
<p>The Utilities module contains stand-alone functions needed for simple
plotting and interpolation. These merely serve as examples and it is highly
encouraged to adapt these functions for visualising datasets</p>
<dl class="py function">
<dt class="sig sig-object py" id="Utilities.arrowplot">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">arrowplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xend</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yend</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headangle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.arrowplot" title="Permalink to this definition"></a></dt>
<dd><p>Plot arrows to denote the direction and magnitude of the displacement.
Direction is indicated by the bearing of the arrow, and the magnitude is
indicated by the length of the arrow</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>arr</em>) – X coordinates for pt0</p></li>
<li><p><strong>y0</strong> (<em>arr</em>) – Y coordinates for pt0</p></li>
<li><p><strong>x1</strong> (<em>arr</em>) – X coordinates for pt1</p></li>
<li><p><strong>y1</strong> (<em>arr</em>) – Y coordinates for pt1</p></li>
<li><p><strong>scale</strong> (<em>int</em><em>, </em><em>optional</em>) – Arrow scale (default=1.0)</p></li>
<li><p><strong>headangle</strong> (<em>int</em><em>, </em><em>optional</em>) – Plotting angle (default=15)</p></li>
<li><p><strong>headscale</strong> (<em>int</em><em>, </em><em>optional</em>) – Arrow head scale (default=0.2)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xs</strong> (<em>arr</em>) – X coordinates for arrow plots</p></li>
<li><p><strong>ys</strong> (<em>arr</em>) – Y coordinates for arrow plots</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.interpolateHelper">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">interpolateHelper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzvel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyz0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyz1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.interpolateHelper" title="Permalink to this definition"></a></dt>
<dd><p>Function to interpolate a point dataset. This uses functions of
the SciPy package to set up a grid (grid) and then interpolate using a
linear interpolation method (griddata). Methods are those compatible with
SciPy’s interpolate.griddata function: ‘nearest’, ‘cubic’ and ‘linear’.</p>
<dl class="simple">
<dt>xxyzvel<span class="classifier">arr</span></dt><dd><p>Input xyz velocities</p>
</dd>
<dt>xyz0<span class="classifier">arr</span></dt><dd><p>Coordinates (x,y) for points in first image</p>
</dd>
<dt>xyz1<span class="classifier">arr</span></dt><dd><p>Coordinates (x,y) for points in second image</p>
</dd>
<dt>method<span class="classifier">str, optional</span></dt><dd><p>Interpolation method (default=’linear’)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>grid</strong> (<em>arr</em>) – Interpolated grid of points</p></li>
<li><p><strong>pointsextent</strong> (<em>list</em>) – Grid extent</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotAreaPX">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotAreaPX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotAreaPX" title="Permalink to this definition"></a></dt>
<dd><p>Plot figure with image overlayed with pixel area features</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uv</strong> (<em>arr</em>) – Input uv coordinates for plotting over image</p></li>
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether the figure is shown (default=True)</p></li>
<li><p><strong>save</strong> (<em>str</em><em>, </em><em>optional</em>) – Destination file to save figure to (default=None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotAreaXYZ">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotAreaXYZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotAreaXYZ" title="Permalink to this definition"></a></dt>
<dd><p>Plot figure with image overlayed with xyz coordinates representing
either areas or line features</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyz</strong> (<em>arr</em>) – Input xyz coordinates for plotting</p></li>
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – Underlying DEM for plotting over</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether the figure is shown (default=True)</p></li>
<li><p><strong>save</strong> (<em>str</em><em>, </em><em>optional</em>) – Destination file to save figure to (default=None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotCalib">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotCalib</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distortion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotCalib" title="Permalink to this definition"></a></dt>
<dd><p>Function to show camera calibration. Two images are plotted, the
first with the original input image and the second with the calibrated
image. This calibrated image is corrected for distortion using the
distortion parameters held in the PyTrx.CamEnv.CamCalib object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>arr</em>) – Camera matrix</p></li>
<li><p><strong>distortion</strong> (<em>arr</em>) – Distortion cofficients</p></li>
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>imn</strong> (<em>str</em>) – Image name</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotGCPs">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotGCPs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gcps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotGCPs" title="Permalink to this definition"></a></dt>
<dd><p>Function to show the ground control points, on the image and the DEM</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gcps</strong> (<em>arr</em>) – GCPs</p></li>
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>imn</strong> (<em>str</em>) – </p></li>
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – DEM object</p></li>
<li><p><strong>extent</strong> (<em>list</em><em>, </em><em>optional</em>) – DEM extent indicator (default=None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotInterpolate">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotInterpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointextent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotInterpolate" title="Permalink to this definition"></a></dt>
<dd><p>Function to plot the results of the velocity interpolation process for
a particular image pair.</p>
<dl class="simple">
<dt>grid<span class="classifier">arr</span></dt><dd><p>Numpy grid. It is recommended that this is constructed using
PyTrx.Utilites.interpolateHelper</p>
</dd>
<dt>pointextent<span class="classifier">list</span></dt><dd><p>Grid extent</p>
</dd>
<dt>dem<span class="classifier">PyTrx.DEM.ExplicitRaster</span></dt><dd><p>Underlying DEM for plotting over</p>
</dd>
<dt>show<span class="classifier">bool, optional</span></dt><dd><p>Flag to denote whether the figure is shown (default=True)</p>
</dd>
<dt>save<span class="classifier">str, optional</span></dt><dd><p>Destination file to save figure to (default=True)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotLinePX">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotLinePX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotLinePX" title="Permalink to this definition"></a></dt>
<dd><p>Plot figure with image overlayed with pixel line features</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uv</strong> (<em>arr</em>) – Input uv coordinates for plotting over image</p></li>
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether the figure is shown (defatul=True)</p></li>
<li><p><strong>save</strong> (<em>str</em><em>, </em><em>optional</em>) – Destination file to save figure to (default=None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotLineXYZ">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotLineXYZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotLineXYZ" title="Permalink to this definition"></a></dt>
<dd><p>Plot figure with image overlayed with xyz coordinates representing
either areas or line features</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyz</strong> (<em>arr</em>) – Input xyz coordinates for plotting</p></li>
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – Underlying DEM for plotting over</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether the figure is shown (default=True)</p></li>
<li><p><strong>save</strong> (<em>str</em><em>, </em><em>optional</em>) – Destination file to save figure to (default=None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotPrincipalPoint">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotPrincipalPoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">camcen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotPrincipalPoint" title="Permalink to this definition"></a></dt>
<dd><p>Function to show the principal point on the image, along with the
GCPs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>camcen</strong> (<em>list</em>) – Principal point coordinates</p></li>
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>imn</strong> (<em>str</em>) – Image name</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotResiduals">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotResiduals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gcp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gcp2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gcp3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotResiduals" title="Permalink to this definition"></a></dt>
<dd><p>Function to plot sets of points to show offsets. This is
commonly used for inspecting differences between image GCPs and projected
GCPs, e.g. within the optimiseCamera function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>ims</strong> (<em>list</em>) – Image dimension (height, width)</p></li>
<li><p><strong>gcp1</strong> (<em>arr</em>) – Array with uv positions of image gcps</p></li>
<li><p><strong>gcp2</strong> (<em>arr</em>) – Array with initial uv positions of projected gcps</p></li>
<li><p><strong>gcp3</strong> (<em>arr</em>) – Array with optimised uv positions of projected gcps</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotVeloPX">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotVeloPX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uvvel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotVeloPX" title="Permalink to this definition"></a></dt>
<dd><p>Plot figure with image overlayed with pixel velocities. UV data are
depicted as the uv point in img0 and the corresponding pixel velocity as a
proportional arrow (computed using the arrowplot function)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uvvel</strong> (<em>arr</em>) – Input pixel velocities</p></li>
<li><p><strong>uv0</strong> (<em>arr</em>) – Coordinates (u,v) for points in first image</p></li>
<li><p><strong>uv1</strong> (<em>arr</em>) – Coordinates (u,v) for points in second image</p></li>
<li><p><strong>img</strong> (<em>arr</em>) – Image array</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether the figure is shown (default=True)</p></li>
<li><p><strong>save</strong> (<em>str</em><em>, </em><em>optional</em>) – Destination file to save figure to (default=None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Utilities.plotVeloXYZ">
<span class="sig-prename descclassname"><span class="pre">Utilities.</span></span><span class="sig-name descname"><span class="pre">plotVeloXYZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzvel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyz0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyz1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Utilities.plotVeloXYZ" title="Permalink to this definition"></a></dt>
<dd><p>Plot figure with image overlayed with xyz velocities. XYZ data are
depicted as the xyz point in img0 and the corresponding velocity as a
proportional arrow (computed using the arrowplot function)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyzvel</strong> (<em>arr</em>) – Input xyz velocities</p></li>
<li><p><strong>xyz0</strong> (<em>arr</em>) – Coordinates (x,y) for points in first image</p></li>
<li><p><strong>xyz1</strong> (<em>arr</em>) – Coordinates (x,y) for points in second image</p></li>
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – Underlying DEM for plotting over</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote whether the figure is shown (default=True)</p></li>
<li><p><strong>save</strong> (<em>str</em><em>, </em><em>optional</em>) – Destination file to save figure to (default=True)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-Velocity">
<span id="velocity-module"></span><h2>Velocity module<a class="headerlink" href="#module-Velocity" title="Permalink to this headline"></a></h2>
<p>The Velocity module handles the functionality for obtaining velocity and
homography measurements from oblique time-lapse imagery. Specifically, this
module contains functions for: (1) Performing camera registration from static
point feature tracking (referred to here as homography); and (2) Calculating
surface velocities derived from feature tracking, with associated errors and
signal-to-noise ratio calculated. These functions can be performed with either
a sparse or dense method, using corner features for tracking in the sparse
method and a grid of evenly space points in the dense method</p>
<dl class="py class">
<dt class="sig sig-object py" id="Velocity.Homography">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">Homography</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imageList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camEnv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invmaskPath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibFlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.Homography" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#Images.ImageSequence" title="Images.ImageSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Images.ImageSequence</span></code></a></p>
<p>A class for the processing the homography of an image sequence to
determine motion in a camera platform. This class treats the images as a
contigous sequence of name references by default</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~Homography._camEnv</strong> (<em>PyTrx.CamEnv.CamEnv</em>) – Camera environment object</p></li>
<li><p><strong>~Homography._imageN</strong> (<em>int</em>) – Image sequence size</p></li>
<li><p><strong>~Homography._calibFlag</strong> (<em>bool</em>) – Image calibration flag</p></li>
<li><p><strong>~Homography._invmask</strong> (<em>arr</em>) – Inverse mask array</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Velocity.Homography.calcHomographies">
<span class="sig-name descname"><span class="pre">calcHomographies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cv2.RANSAC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ransacReprojThreshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.Homography.calcHomographies" title="Permalink to this definition"></a></dt>
<dd><p>Function to generate a homography model through a sequence of
images, and perform for image registration. Points that are assumed
to be static in the image plane are tracked between image pairs, and
movement in these points are used to generate sequential homography
models.
Input example:
For sparse homographies:
homog = Homography.calcHomographies([[‘sparse’], [50000, 0.1, 5],
[(25,25), 1.0, 4]])
For dense homographies:
homog = Homography.calcHomographies([[‘dense’], [100,100],
[cv2.TM_CCORR_NORMED, 50, 100, 1.0, 4]])</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>list</em>) – List that defines the parameters for point matching: Method: ‘sparse’
or ‘dense’ (str). Seed parameters: either containing the
cornerparameters for the sparse method - max. number of corners
(int), quality (int), and min. distance (int). Or the grid spacing
(list) for the dense method. Tracking parameters: either containing
the sparse method parameters - window size (tuple), backtracking
threshold(int) and minimum tracked features (int). Or the dense
method parameters - tracking method (int), template size (int),
search window size (int), backtracking threshold (int), and minimum
tracked features (int)</p></li>
<li><p><strong>homogmethod</strong> (<em>int</em><em>, </em><em>optional</em>) – Method used to calculate homography model, which plugs into the
OpenCV function. This can either be cv2.RANSAC (a RANSAC-based robust
method), cv2.LEAST_MEDIAN (a Least-Median robust method) or ‘0’ (a
regular method using all the points)(default=cv2.RANSAC)</p></li>
<li><p><strong>ransacReprojThreshold</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum allowed reprojection error (default=5.0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>homog</strong> – A list of homography information for all image pairs in sequence</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Velocity.Homography.getInverseMask">
<span class="sig-name descname"><span class="pre">getInverseMask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.Homography.getInverseMask" title="Permalink to this definition"></a></dt>
<dd><p>Return inverse mask</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Velocity.TestVelocity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">TestVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.TestVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="Velocity.TestVelocity.test_apply_persp_homographyPts">
<span class="sig-name descname"><span class="pre">test_apply_persp_homographyPts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.TestVelocity.test_apply_persp_homographyPts" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Velocity.Velocity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">Velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imageList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camEnv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homography</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maskPath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibFlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.Velocity" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#Images.ImageSequence" title="Images.ImageSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Images.ImageSequence</span></code></a></p>
<p>A class for the processing of an ImageSet to determine pixel
displacements and real-world velocities from a sparse set of points, with
methods to track in the xy image plane and project tracks to real-world
(xyz) coordinates. This class treats the images as a contigous sequence of
name references by default</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>~Velocity._camEnv</strong> (<em>PyTrx.CamEnv.CamEnv</em>) – Camera environment object</p></li>
<li><p><strong>~Velocity._homog</strong> (<em>PyTrx.Velocity.Homography</em>) – Homography object</p></li>
<li><p><strong>~Velocity._imageN</strong> (<em>int</em>) – Image sequence size</p></li>
<li><p><strong>~Velocity._calibFlag</strong> (<em>bool</em>) – Image calibration flag</p></li>
<li><p><strong>~Velocity._mask</strong> (<em>arr</em>) – Mask array</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Velocity.Velocity.calcVelocities">
<span class="sig-name descname"><span class="pre">calcVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.Velocity.calcVelocities" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate velocities between succesive image pairs.
Image pairs are called from the ImageSequence object. Points are seeded
in the first of these pairs using the Shi-Tomasi algorithm with
OpenCV’s goodFeaturesToTrack function.
The Lucas Kanade optical flow algorithm is applied using the OpenCV
function calcOpticalFlowPyrLK to find these tracked points in the
second image of each image pair. A backward tracking method then tracks
back from these to the first image in the pair, checking if this is
within a certain distance as a validation measure.
Tracked points are corrected for image distortion and camera platform
motion (if needed). The points in each image pair are georectified
subsequently to obtain xyz points. The georectification functions are
called from the Camera Environment object, and are based on those in
ImGRAFT (Messerli and Grinsted, 2015). Velocities are finally derived
from these using a simple Pythagoras’ theorem method.
This function returns the xyz velocities and points from each image
pair, and their corresponding uv velocities and points in the image
plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>str</em>) – List that defines the parameters for deriving velocity: Method:
‘sparse’ or ‘dense’ (str). Seed parameters: either containing the
corner parameters for the sparse method - max. number of corners
(int), quality (int), and min. distance (int). Or the grid spacing
(list) for the dense method. Tracking parameters: either containing
the sparse method parameters - window size (tuple), backtracking
threshold (int) and minimum tracked features (int). Or the dense
method parameters - tracking method (int), template size (int),
search window size (int), correlation threshold (int), and minimum
tracked features (int)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>velocity</strong> – A list containing the xyz and uv velocities. The first element holds
the xyz velocity for each point (xyz[0]), the xyz positions for the
points in the first image (xyz[1]), and the xyz positions for the
points in the second image(xyz[2]). The second element contains the
uv velocities for each point (uv[0], the uv positions for the points
in the first image (uv[1]), the uv positions for the points in the
second image (uv[2]), and the corrected uv points in the second image
if they have been calculated using the homography model for image
registration (uv[3]). If the corrected points have not been
calculated then an empty list is merely returned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Velocity.Velocity.getCamEnv">
<span class="sig-name descname"><span class="pre">getCamEnv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.Velocity.getCamEnv" title="Permalink to this definition"></a></dt>
<dd><p>Returns the camera environment object (PyTrx.CamEnv.CamEnv)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Velocity.Velocity.getMask">
<span class="sig-name descname"><span class="pre">getMask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.Velocity.getMask" title="Permalink to this definition"></a></dt>
<dd><p>Returns the image mask</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.apply_persp_homographyPts">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">apply_persp_homographyPts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homog</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.apply_persp_homographyPts" title="Permalink to this definition"></a></dt>
<dd><p>Funtion to apply a perspective homography to a sequence of 2D
values held in X and Y. The perspective homography is represented as a
3 X 3 matrix (homog). The source points are inputted as an array. The
homography perspective matrix is modelled in the same manner as done so
in OpenCV</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pts</strong> (<em>arr/list</em>) – Input point positions to correct</p></li>
<li><p><strong>homog</strong> (<em>arr</em>) – Perspective homography matrix</p></li>
<li><p><strong>inverse</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to denote if perspective homography matrix needs inversing
(default=False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hpts</strong> – Corrected point positions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.calcDenseHomography">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">calcDenseHomography</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">griddistance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">templatesize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">searchsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projvars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trackmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cv2.TM_CCORR_NORMED</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cv2.RANSAC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ransacReprojThreshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.calcDenseHomography" title="Permalink to this definition"></a></dt>
<dd><p>Function to supplement correction for movement in the camera
platform given an image pair (i.e. image registration). Returns the
homography representing tracked image movement, and the tracked
features from each image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img1</strong> (<em>arr</em>) – Image 1 in the image pair</p></li>
<li><p><strong>img2</strong> (<em>arr</em>) – Image 2 in the image pair</p></li>
<li><p><strong>mask</strong> (<em>arr</em>) – Mask array for image points to be seeded</p></li>
<li><p><strong>correct</strong> (<em>list</em>) – Calibration parameters for correcting image for lens distortion</p></li>
<li><p><strong>griddistance</strong> (<em>list</em>) – Grid spacing, defined by two values representing pixel row and column
spacing</p></li>
<li><p><strong>templatesize</strong> (<em>int</em>) – Template window size in im0 for matching</p></li>
<li><p><strong>searchsize</strong> (<em>int</em>) – Search window size in im1 for matching</p></li>
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – DEM object</p></li>
<li><p><strong>projvars</strong> (<em>list</em>) – List containing projection parameters (camera location, camera position,
radial distortion coefficients, tangential distortion coefficients,
focal length, camera centre, and reference image)</p></li>
<li><p><strong>trackmethod</strong> (<em>int</em>) – Method for tmeplate matching: cv2.TM_CCOEFF - Cross-coefficient;
cv2.TM_CCOEFF_NORMED - Normalised cross-coeff; cv2.TM_CCORR - Cross
correlation; cv2.TM_CCORR_NORMED - Normalised cross-corr; cv2.TM_SQDIFF -
Square difference; cv2.TM_SQDIFF_NORMED - Normalised square diff</p></li>
<li><p><strong>homogmethod</strong> (<em>int</em><em>, </em><em>optional</em>) – Method used to calculate homography model: cv2.RANSAC - RANSAC-based
robust method; cv2.LEAST_MEDIAN - Least-Median robust; 0 - a regular
method using all the points (default=None)</p></li>
<li><p><strong>ransacReprojThreshold</strong> (<em>int</em><em>, </em><em>optional</em>) – Feature tracking certainty threshold (default=5.0)</p></li>
<li><p><strong>theshold</strong> (<em>int</em><em>, </em><em>optional</em>) – Threshold for template correlation (default=0.8)</p></li>
<li><p><strong>min_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Minimum number of seeded points to track (default=4)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>homogMatrix (arr) - The calculated homographic shift for the image pair;
src_pts_corr (arr) - original homography points; dst_pts_corr (arr) -
tracked homography points; homog_pts (arr) -back-tracked homography points;
ptserror (list) - Difference between the original homography points and
the back-tracked points; homogerror (list) -Difference between the
interpolated homography matrix and the equivalent tracked points</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.calcDenseVelocity">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">calcDenseVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">griddistance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">templatesize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">searchsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">campars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.calcDenseVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate the velocity between a pair of images using
a gridded template matching approach. Gridded points are defined by grid
distance, which are then used to either generate templates for matching
or tracked using the Lucas Kanade optical flow algorithm.
Tracked points are corrected for image distortion and camera platform
motion (if needed). The points in the image pair are georectified
subsequently to obtain xyz points.  The georectification functions are
called from the Camera Environment object, and are based on those in
ImGRAFT (Messerli and Grinsted, 2015). Velocities are finally derived
from these using a simple Pythagoras’ theorem method. This function returns
the xyz velocities and points, and their corresponding uv velocities and
points in the image plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im0</strong> (<em>arr</em>) – Image 1 in the image pair</p></li>
<li><p><strong>im1</strong> (<em>arr</em>) – Image 2 in the image pair</p></li>
<li><p><strong>griddistance</strong> (<em>list</em>) – Grid spacing, defined by two values representing pixel row and column
spacing</p></li>
<li><p><strong>method</strong> (<em>int</em>) – Method for tmeplate matching: cv2.TM_CCOEFF - Cross-coefficient;
cv2.TM_CCOEFF_NORMED - Normalised cross-coeff; cv2.TM_CCORR -
Cross correlation; cv2.TM_CCORR_NORMED - Normalised cross-corr;
cv2.TM_SQDIFF - Square difference; cv2.TM_SQDIFF_NORMED - Normalised
square diff</p></li>
<li><p><strong>templatesize</strong> (<em>int</em>) – Template window size in im0 for matching</p></li>
<li><p><strong>searchsize</strong> (<em>int</em>) – Search window size in im1 for matching</p></li>
<li><p><strong>mask</strong> (<em>arr</em>) – Mask array for masking DEM</p></li>
<li><p><strong>calib</strong> (<em>list</em><em>, </em><em>optional</em>) – Calibration parameters (default=None)</p></li>
<li><p><strong>homog</strong> (<em>list</em><em>, </em><em>optional</em>) – Homography parameters, hmatrix (arr) and hpts (arr) (default=None)</p></li>
<li><p><strong>campars</strong> (<em>list</em><em>, </em><em>optional</em>) – List containing information for transforming between the image plane and
3D scene: 1. DEM (ExplicitRaster object); 2. Projection parameters
(camera location, camera position, radial distortion coefficients,
tangential distortion coefficients, focal length, camera centre, and
reference image); 3. Inverse projection parameters (coordinate system
3D scene - X, Y, Z, uv0) (default=None)</p></li>
<li><p><strong>theshold</strong> (<em>int</em><em>, </em><em>optional</em>) – Threshold for template correlation (default=0.8)</p></li>
<li><p><strong>min_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Minimum number of seeded points to track (default=4)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Two lists, 1. containing the xyz velocities for each point (xyz[0]), the
xyz positions for the points in the first image (xyz[1]), and the xyz
positions for the points in the second image(xyz[2]); amd 2. containing
the uv velocities for each point (uv[0], the uv positions for the points
in the first image (uv[1]), the uv positions for the points in the second
image (uv[2]), and the corrected uv points in the second image if they
have been calculated using the homography model for image registration
(uv[3]). If the corrected points have not been calculated then an empty
list is merely returned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.calcSparseHomography">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">calcSparseHomography</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cv2.RANSAC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ransacReprojThreshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(25,</span> <span class="pre">25)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">back_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seedparams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[50000,</span> <span class="pre">0.1,</span> <span class="pre">5.0]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.calcSparseHomography" title="Permalink to this definition"></a></dt>
<dd><p>Function to supplement correction for movement in the camera
platform given an image pair (i.e. image registration). Returns the
homography representing tracked image movement, and the tracked
features from each image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img1</strong> (<em>arr</em>) – Image 1 in the image pair</p></li>
<li><p><strong>img1</strong> – Image 2 in the image pair</p></li>
<li><p><strong>mask</strong> (<em>arr</em>) – Mask array for image points to be seeded</p></li>
<li><p><strong>correct</strong> (<em>list</em><em>, </em><em>optional</em>) – Calibration parameters for correcting image for lens distortion
(default=None)</p></li>
<li><p><strong>method</strong> (<em>int</em><em>, </em><em>optional</em>) – Method used to calculate homography model: cv2.RANSAC - RANSAC-based
robust method; cv2.LEAST_MEDIAN - Least-Median robust; 0 - a regular
method using all the points (default=None)</p></li>
<li><p><strong>ransacReprojThreshold</strong> (<em>int</em><em>, </em><em>optional</em>) – Feature tracking certainty threshold (default=5.0)</p></li>
<li><p><strong>winsize</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Feature tracking window size (default=(25, 25))</p></li>
<li><p><strong>back_thesh</strong> (<em>int</em><em>, </em><em>optional</em>) – Threshold for back-tracking distance (i.e.the difference between the
original seeded point and the back-tracked point in im0) (default=1.0)</p></li>
<li><p><strong>min_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Minimum number of seeded points to track (default=4)</p></li>
<li><p><strong>seedparams</strong> (<em>list</em><em>, </em><em>optional</em>) – Point seeding parameters, which indicate whether points are generated
based on corner features or a grid with defined spacing. The three corner
features parameters denote maximum number of corners detected, corner
quality, and minimum distance between corners; inputted as a list. For
grid generation, the only input parameter needed is the grid spacing;
inputted as a list containing the horizontal and vertical grid spacing
(default=[50000, 0.1, 5.0])</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tuple containing homogMatrix (arr) - The calculated homographic shift for
the image pair; src_pts_corr (arr) - original homography points;
dst_pts_corr (arr) - tracked homography points; homog_pts (arr) -
back-tracked homography points; ptserror (list) - Difference between the
original homography points and the back-tracked points; homogerror (list)
- Difference between the interpolated homography matrix and the
equivalent tracked points</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.calcSparseVelocity">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">calcSparseVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(25,</span> <span class="pre">25)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">back_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seedparams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[50000,</span> <span class="pre">0.1,</span> <span class="pre">5.0]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.calcSparseVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Function to calculate the velocity between a pair of images. Points
are seeded in the first of these either by a defined grid spacing, or using
the Shi-Tomasi algorithm with OpenCV’s goodFeaturesToTrack function.
The Lucas Kanade optical flow algorithm is applied using the OpenCV
function calcOpticalFlowPyrLK to find these tracked points in the
second image. A backward tracking method then tracks back from these to
the original points, checking if this is within a certain distance as a
validation measure.
Tracked points are corrected for image distortion and camera platform
motion (if needed). The points in the image pair are georectified
subsequently to obtain xyz points.  The georectification functions are
called from the <code class="xref py py-class docutils literal notranslate"><span class="pre">PyTrx.CamEnv.CamEnv</span></code> object, and are based on those
in ImGRAFT (Messerli and Grinsted, 2015). Velocities are finally derived
from these using a simple Pythagoras’ theorem method. This function returns
the xyz velocities and points, and their corresponding uv velocities and
points in the image plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img1</strong> (<em>arr</em>) – Image 1 in the image pair</p></li>
<li><p><strong>img2</strong> (<em>arr</em>) – Image 2 in the image pair</p></li>
<li><p><strong>mask</strong> (<em>arr</em>) – Mask array</p></li>
<li><p><strong>calib</strong> (<em>list</em><em>, </em><em>optional</em>) – Calibration parameters (default=None)</p></li>
<li><p><strong>homog</strong> (<em>list</em><em>, </em><em>optional</em>) – Homography model parameters</p></li>
<li><p><strong>invprojvars</strong> (<em>list</em><em>, </em><em>optional</em>) – Inverse projection parameters for georectification (default=None)</p></li>
<li><p><strong>winsize</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Feature tracking window size (default=(25, 25))</p></li>
<li><p><strong>back_thesh</strong> (<em>int</em><em>, </em><em>optional</em>) – Threshold for back-tracking distance (i.e.the difference between the
original seeded point and the back-tracked point in im0) (default=1.0)</p></li>
<li><p><strong>min_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Minimum number of seeded points to track (default=4)</p></li>
<li><p><strong>seedparams</strong> (<em>list</em><em>, </em><em>optional</em>) – Point seeding parameters, which indicate whether points are generated
based on corner features or a grid with defined spacing. The three corner
features parameters denote maximum number of corners detected, corner
quality, and minimum distance between corners; inputted as a list. For
grid generation, the only input parameter needed is the grid spacing;
inputted as a list containing the horizontal and vertical grid spacing.
(default=[50000, 0.1, 5.0])</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Two lists, 1. The xyz velocities for each point (xyz[0]), the xyz
positions for the points in the first image (xyz[1]), and the xyz
positions for the points in the second image(xyz[2]); 2. The uv
velocities for each point (uv[0], the uv positions for the points in the
first image (uv[1]), the uv positions for the points in the second image
(uv[2]), and the corrected uv points in the second image if they have
been calculated using the homography model for image registration
(uv[3]). If the corrected points have not been calculated then an empty
list is merely returned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.opticalMatch">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">opticalMatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">back_thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_features</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.opticalMatch" title="Permalink to this definition"></a></dt>
<dd><p>Function to match between two masked images using Optical Flow. The
Lucas Kanade optical flow algorithm is applied using the OpenCV function
calcOpticalFlowPyrLK to find these tracked points in the second image. A
backward tracking then tracks back from these to the original points,
checking if this is within a given number of pixels as a validation
measure. The resulting error is the difference between the original feature
point and the backtracked feature point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i0</strong> (<em>arr</em>) – Image 1 in the image pair</p></li>
<li><p><strong>iN</strong> (<em>arr</em>) – Image 2 in the image pair</p></li>
<li><p><strong>p0</strong> (<em>arr</em>) – Vector of 2D points for which the flow needs to be found</p></li>
<li><p><strong>winsize</strong> (<em>tuple</em>) – Window size for tracking e.g. (25,25)</p></li>
<li><p><strong>back_thesh</strong> (<em>int</em>) – Threshold for back-tracking distance (i.e. the difference between the
original seeded point and the back-tracked point in im0)</p></li>
<li><p><strong>min_features</strong> (<em>int</em>) – Minimum number of seeded points to track</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>[p0,p1,p0r]</strong> (<em>list</em>) – Point coordinates for points tracked to image 2 (arr), Point coordinates
for points back-tracked from image 2 to image 1 (arr), and SNR
measurements for the corresponding tracked point. The signal is the
magnitude of the displacement from p0 to p1, and the noise is the
magnitude of the displacement from p0r to p0 (arr)</p></li>
<li><p><strong>error</strong> (<em>arr</em>) – Tracking error</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.readDEMmask">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">readDEMmask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invprojvars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demMaskPath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.readDEMmask" title="Permalink to this definition"></a></dt>
<dd><p>Read/generate DEM mask for subsequent grid generation. If a valid
filename is given then the DEM mask is loaded from file. If the filename
does not exist, then the mask is defined. To define the DEM mask, a mask is
first defined in the image plane (using point and click, facilitated
through Matplotlib Pyplot’s ginput function), and then projected to the
DEM scene using CamEnv’s projectXYZ function. For the projection to work,
the invprojvars need to be valid X,Y,Z,uv0 parameters, as generated in
CamEnv’s setProjection function. The mask is saved to file if a filepath is
given. This DEM mask can be used for dense feature-tracking/template
matching, where masked regions of the DEM are reassigned to
NaN using Numpy’s ma.mask function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – DEM object</p></li>
<li><p><strong>img</strong> (<em>arr</em>) – Image to initially define mask in</p></li>
<li><p><strong>invprojvars</strong> (<em>list</em>) – Inverse projection variables [X,Y,Z,uv0]</p></li>
<li><p><strong>demMaskPath</strong> (<em>str</em><em>, </em><em>optional</em>) – File path to outputted mask file (default=None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>demMask</strong> – A Boolean visibility matrix (which is the same dimensions as the dem)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.seedCorners">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">seedCorners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quality</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mindist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_features</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.seedCorners" title="Permalink to this definition"></a></dt>
<dd><p>Function to seed corner features using the Shi-Tomasi corner feature
detection method in OpenCV’s goodFeaturesToTrack function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>arr</em>) – Image for seeding corner points</p></li>
<li><p><strong>mask</strong> (<em>arr</em>) – Mask array for points to be seeded</p></li>
<li><p><strong>maxpoints</strong> (<em>int</em>) – Maximum number of corners detected</p></li>
<li><p><strong>quality</strong> (<em>int</em>) – Corner quality (between 0.0 and 1.0)</p></li>
<li><p><strong>mindist</strong> (<em>int</em>) – Minimum distance between corners</p></li>
<li><p><strong>min_features</strong> (<em>int</em>) – Minimum number of seeded points to track</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p0</strong> – Point coordinates for corner features seeded in image</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.seedGrid">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">seedGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">griddistance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projvars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.seedGrid" title="Permalink to this definition"></a></dt>
<dd><p>Define pixel grid at a specified grid distance, taking into
consideration the image size and image mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dem</strong> (<em>PyTrx.DEM.ExplicitRaster</em>) – DEM object</p></li>
<li><p><strong>griddistance</strong> (<em>list</em>) – Grid spacing, defined by two values representing pixel row and column
spacing</p></li>
<li><p><strong>projvars</strong> (<em>list</em>) – Projection parameters (camera location, camera position, radial
distortion coefficients, tangential distortion coefficients, focal
length, camera centre, and reference image)</p></li>
<li><p><strong>mask</strong> (<em>arr</em>) – Mask array for masking DEM</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xyz</strong> (<em>arr</em>) – Grid point positions in the DEM coordinate system</p></li>
<li><p><strong>uv</strong> (<em>arr</em>) – Grid point positions in the image coordinate system</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Velocity.templateMatch">
<span class="sig-prename descclassname"><span class="pre">Velocity.</span></span><span class="sig-name descname"><span class="pre">templateMatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">templatesize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">searchsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cv2.TM_CCORR_NORMED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Velocity.templateMatch" title="Permalink to this definition"></a></dt>
<dd><p>Function to template match between two images. Templates in the first
image (im0) are generated from a given set of points (uv0) and matched to
the search window in image 2 (im1). There are a series of methods that can
be used for matching, in adherence with those offered with OpenCV’s
matchTemplate function. After matching, the origin point of each matched
template in image 2 is returned, along with the average correlation in
each template</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im0</strong> (<em>arr</em>) – Image 1 in the image pair</p></li>
<li><p><strong>im1</strong> (<em>arr</em>) – Image 2 in the image pair</p></li>
<li><p><strong>uv0</strong> (<em>tuple</em>) – Grid points for image 1</p></li>
<li><p><strong>templatesize</strong> (<em>int</em>) – Template window size in im0 for matching</p></li>
<li><p><strong>searchsize</strong> (<em>int</em>) – Search window size in im1 for matching</p></li>
<li><p><strong>min_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Minimum number of seeded points to track (default=4)</p></li>
<li><p><strong>method</strong> (<em>int</em>) – Method for tmeplate matching: cv2.TM_CCOEFF - Cross-coefficient;
cv2.TM_CCOEFF_NORMED - Normalised cross-coeff; cv2.TM_CCORR - Cross
correlation; cv2.TM_CCORR_NORMED - Normalised cross-corr; cv2.TM_SQDIFF -
Square difference; cv2.TM_SQDIFF_NORMED - Normalised square diff</p></li>
<li><p><strong>Returns</strong> – </p></li>
<li><p><strong>list</strong> – Point coordinates for points tracked to image 2 (arr), Point coordinates
for points back-tracked from image 2 to image 1 (arr), and SNR
measurements for the corresponding tracked point where the signal is the
magnitude of the displacement from p0 to p1, and the noise is the
magnitude of the displacement from p0r to p0 (arr)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Guide.html" class="btn btn-neutral float-left" title="Package Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Links.html" class="btn btn-neutral float-right" title="Links and Acknowledgements" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Penelope How.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>